# Контейнер служб (Service Container)

[[toc]]

## Введение

Контейнер служб Goravel - это мощный инструмент для управления зависимостями классов и выполнения внедрения зависимостей. Он содержит все модули Goravel и позволяет вам связывать собственные службы с контейнером и разрешать их при необходимости. Контейнер служб предоставляет мощную поддержку для сторонних пакетов вокруг Goravel.

## Регистрация служб

### Простые регистрации

Почти все ваши регистрации контейнеров будут зарегистрированы в [поставщиках служб](./service-providers.md). Внутри поставщика служб у вас всегда есть доступ к контейнеру через параметр `app`, затем регистрируете связывание с помощью метода `Bind`, передавая `key`, который вы хотите зарегистрировать, а также замыкание, которое возвращает экземпляр класса:

```go
package route

import (
	"github.com/goravel/framework/contracts/foundation"
)

const Binding = "goravel.route"

type ServiceProvider struct {
}

func (route *ServiceProvider) Register(app foundation.Application) {
	app.Bind(Binding, func() (any, error) {
		return NewRoute(app.MakeConfig()), nil
	})
}

func (route *ServiceProvider) Boot(app foundation.Application) {

}
```

Как упоминалось ранее, вы обычно будете взаимодействовать с контейнером внутри поставщиков служб; однако, если вы хотите взаимодействовать с контейнером вне поставщика служб, вы можете сделать это через фасад `App`:

```go
facades.App().Bind("key", func() (any, error) {
    ...
})
```

### Связывание как Singleton

Метод `Singleton` связывает класс или интерфейс в контейнере, который должен быть разрешен только один раз. После разрешения связывания синглтона будет возвращаться тот же самый экземпляр объекта при последующих вызовах контейнера:

```go
app.Singleton(key, func() (any, error) {
    return NewGin(app.MakeConfig()), nil
})
```

### Связывание экземпляров

Вы также можете связать существующий экземпляр объекта в контейнере, используя метод `Instance`. Указанный экземпляр всегда будет возвращаться при последующих вызовах контейнера:

```go
app.Instance(key, instance)
```

### Связывание с параметрами

Если вам нужны дополнительные параметры для создания службы, вы можете использовать метод `BindWith` для передачи параметров в замыкание:

```go
app.BindWith(Binding, func(parameters map[string]any) (any, error) {
    return NewRoute(app.MakeConfig()), nil
})
```

## Разрешение зависимостей

### Метод `Make`

Вы можете использовать метод `Make` для разрешения экземпляра класса из контейнера. Метод `Make` принимает ключ `key`, который вы хотите разрешить:

```go
instance, err := app.Make(key)
```

Если вы находитесь за пределами поставщика служб в месте своего кода, где у вас нет доступа к переменной `app`, вы можете использовать фасад `App`, чтобы разрешить экземпляр класса из контейнера:

```go
instance, err := facades.App().Make(key)
```

### Метод `MakeWith`

Если некоторые из зависимостей класса не могут быть разрешены через контейнер, вы можете внедрить их, передав их в ассоциативный массив в метод `MakeWith`, соответствующий методу связывания `BindWith`:

```go
instance, err := app.MakeWith(key, map[string]any{"id": 1})
```

### Другие методы

Фреймворк предоставляет несколько удобных методов для быстрого разрешения различных 
`фасадов`: `MakeArtisan`, `MakeAuth`, `MakeCache`, `MakeConfig`, `MakeCrypt`, `MakeEvent`, `MakeGate`, `MakeGrpc`, `MakeHash`, `MakeLog`, `MakeMail`, `MakeOrm`, `MakeQueue`, `MakeRateLimiter`, `MakeRoute`, `MakeSchedule`, `MakeStorage`, `MakeValidation`.