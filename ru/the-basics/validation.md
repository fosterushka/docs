# Валидация (Validation)

[[toc]]

## Введение

Goravel предоставляет несколько различных подходов для проверки входных данных вашего приложения. Наиболее распространено использование метода `Validate`, доступного для всех входящих HTTP-запросов. Goravel включает в себя широкий спектр удобных правил валидации.

## Быстрый старт с валидацией

Чтобы ознакомиться с мощными возможностями валидации Goravel, давайте рассмотрим полный пример проверки формы и отображения обратно пользователю сообщений об ошибках. Изучив этот обзор на высоком уровне, вы сможете получить общее представление о том, как выполнять валидацию входных данных с помощью Goravel:

### Определение маршрутов

Предположим, что у нас определены следующие маршруты в файле `routes/web.go`:

```go
import "goravel/app/http/controllers"

postController := controllers.NewPostController()
facades.Route().Get("/post/create", postController.Create)
facades.Route().Post("/post", postController.Store)
```

Маршрут `GET` будет отображать форму для создания нового блога, а маршрут `POST` будет сохранять новый блог в базе данных.

### Создание контроллера

Теперь давайте рассмотрим простой контроллер, который обрабатывает входящие запросы к этим маршрутам. Пока что мы оставим метод `Store` пустым:

```go
package controllers

import (
  "github.com/goravel/framework/contracts/http"
)

type PostController struct {
  //Зависимые службы
}

func NewPostController() *PostController {
  return &PostController{
    //Внедрение зависимостей
  }
}

func (r *PostController) Create(ctx http.Context) {

}

func (r *PostController) Store(ctx http.Context) {

}
```

### Написание логики валидации

Теперь мы готовы заполнить наш метод `Store` логикой для проверки нового блога.

```go
func (r *PostController) Store(ctx http.Context) {
  validator, err := ctx.Request().Validate(map[string]string{
    "title": "required|max_len:255",
    "body": "required",
  })
}
```

### Примечание о вложенных атрибутах

Если входящий HTTP-запрос содержит данные с "вложенными" полями, вы можете указать эти поля в правилах валидации с использованием синтаксиса "точка":

```go
validator, err := ctx.Request().Validate(map[string]string{
  "title": "required|max_len:255",
  "author.name": "required",
  "author.description": "required",
})
```

## Валидация через "форму запроса" (Form Request)

### Создание формы запроса

Для более сложных сценариев валидации вы можете создать "форму запроса". Формы запроса - это пользовательские классы запросов, которые включают в себя свою собственную логику проверки и авторизации. Чтобы создать класс формы запроса, вы можете использовать команду Artisan CLI `make:request`:

```go
go run . artisan make:request StorePostRequest
go run . artisan make:request user/StorePostRequest
```

Сгенерированный класс формы запроса будет размещен в директории `app/http/requests`. Если этой директории не существует, Goravel создаст ее при выполнении команды `make:request`. Каждый сгенерированный класс формы запроса содержит два метода: `Authorize`, `Rules`, `Messages`, `Attributes` и `PrepareForValidation`.

Как вы могли догадаться, метод `Authorize` отвечает за определение, может ли текущий аутентифицированный пользователь выполнить действие, представленное запросом, в то время как метод `Rules` возвращает правила валидации, которые должны применяться к данным запроса:

```go
package requests

import (
  "github.com/goravel/framework/contracts/http"
  "github.com/goravel/framework/contracts/validation"
)

type StorePostRequest struct {
  Name string `form:"name" json:"name"`
}

func (r *StorePostRequest) Authorize(ctx http.Context) error {
  return nil
}

func (r *StorePostRequest) Rules(ctx http.Context) map[string]string {
  return map[string]string{
    // Ключи соответствуют входящим ключам.
    "name": "required|max_len:255",
  }
}

func (r *StorePostRequest) Messages(ctx http.Context) map[string]string {
  return map[string]string{}
}

func (r *StorePostRequest) Attributes(ctx http.Context) map[string]string {
  return map[string]string{}
}

func (r *StorePostRequest) PrepareForValidation(ctx http.Context, data validation.Data) error {
  return nil
}
```

Таким образом, как выполняются проверки правил валидации? Вам просто нужно указать класс запроса в сигнатуре метода контроллера. Перед вызовом метода контроллера, входной запрос проверяется, что позволяет избежать перегруженности контроллера логикой валидации:

```go
func (r *PostController) Store(ctx http.Context) {
  var storePost requests.StorePostRequest
  errors, err := ctx.Request().ValidateRequest(&storePost)
}
```

> Обратите внимание, что поскольку переданные значения из `form` по умолчанию имеют тип `string`, все поля в запросе также должны быть типа `string`, иначе воспользуйтесь `JSON` для передачи значений.

### Авторизация формы запроса

В классе формы запроса также содерж

ится метод `Authorize`. В этом методе вы можете определить, имеет ли аутентифицированный пользователь действительно право выполнять данное действие. Например, вы можете определить, что пользователь действительно является владельцем комментария блога, который он пытается обновить. Скорее всего, вы будете взаимодействовать с вашими [воротами (Gates) и политиками (Policies)](../security/authorization.md) внутри этого метода:

```go
func (r *StorePostRequest) Authorize(ctx http.Context) error {
  var comment models.Comment
  facades.Orm().Query().First(&comment)
  if comment.ID == 0 {
    return errors.New("no comment is found")
  }

  if !facades.Gate().Allows("update", map[string]any{
    "comment": comment,
  }) {
    return errors.New("can't update comment")
  }

  return nil
}
```

`error` будет передан возвращаемому значению из `ctx.Request().ValidateRequest`.

### Настройка пользовательских сообщений об ошибках

Вы можете настроить сообщения об ошибках, используемые классом формы запроса, переопределив метод `Messages`. Этот метод должен возвращать массив пар атрибут/правило и соответствующее сообщение об ошибке валидации:

```go
func (r *StorePostRequest) Messages() map[string]string {
  return map[string]string{
    "title.required": "A title is required",
    "body.required": "A message is required",
  }
}
```

### Настройка атрибутов для валидации

Во многих встроенных правилах валидации Goravel присутствует заполнитель `:attribute`, который заменяется именем поля или атрибута, проходящего валидацию. Если вы хотите настроить значения, которые будут использоваться вместо этих заполнителей для конкретных полей, вы можете передать массив пользовательских атрибутов в метод `Attributes`:

```go
func (r *StorePostRequest) Attributes() map[string]string {
  return map[string]string{
    "email": "email address",
  }
}
```

### Подготовка данных для валидации

Если вам необходимо подготовить или преобразовать данные из запроса перед применением правил валидации, вы можете использовать метод `PrepareForValidation`:

```go
func (r *StorePostRequest) PrepareForValidation(data validation.Data) error {
  if name, exist := data.Get("name"); exist {
    _, _ = data.Set("name", name.(string)+"1")
  }
}
```

## Ручное создание валидаторов

Если вы не хотите использовать метод `Validate` для запроса, вы можете создать экземпляр валидатора вручную, используя `facades.Validator`. Метод `Make` на фасаде генерирует новый экземпляр валидатора:

```go
func (r *PostController) Store(ctx http.Context) {
  validator, err := facades.Validation().Make(map[string]any{
    "name": "Goravel",
  }, map[string]string{
    "title": "required|max_len:255",
    "body":  "required",
  })

  if validator.Fails() {
    // Возврат ошибки
  }

  var user models.User
  err := validator.Bind(&user)
}
```

Первый аргумент, передаваемый методу `Make`, - это данные для проверки, которые могут быть `map[string]any` или `struct`. Второй аргумент - это массив правил валидации, которые должны быть применены к данным.

### Настройка пользовательских сообщений об ошибках

Если необходимо, вы можете предоставить пользовательские сообщения об ошибках, которые должен использовать экземпляр валидатора, вместо стандартных сообщений об ошибках, предоставляемых Goravel. Вы можете передать пользовательские сообщения в качестве третьего аргумента метода `Make` (также применимо к `ctx.Request().Validate()`):

```go
validator, err := facades.Validation().Make(input, rules, validation.Messages(map[string]string{
  "required": "The :attribute field is required.",
}))
```

### Указание пользовательского сообщения для конкретного атрибута

Иногда вы можете захотеть указать пользовательское сообщение об ошибке только для определенного атрибута. Это можно сделать с помощью синтаксиса "точка". Укажите сначала имя ат

рибута, затем правило (также применимо к `ctx.Request().Validate()`):

```go
validator, err := facades.Validation().Make(input, rules, validation.Messages(map[string]string{
  "email.required": "We need to know your email address!",
}))
```

### Указание пользовательских значений атрибутов

Многие из встроенных сообщений об ошибках валидации Goravel содержат заполнитель `:attribute`, который заменяется именем поля или атрибута, проходящего валидацию. Чтобы настроить значения, которые будут использоваться для замены этих заполнителей для определенных полей, вы можете передать массив пользовательских атрибутов в качестве третьего аргумента метода `Make` (также применимо к `ctx.Request().Validate()`):

```go
validator, err := facades.Validation().Make(input, rules, validation.Attributes(map[string]string{
  "email": "email address",
}))
```

### Форматирование данных перед валидацией

Вы можете форматировать данные перед валидацией данных для более гибкой валидации данных. Вы можете передать метод форматирования данных в качестве третьего параметра метода `Make` (также применимо к `ctx.Request().Validate()`):

```go
import (
  validationcontract "github.com/goravel/framework/contracts/validation"
  "github.com/goravel/framework/validation"
)

validator, err := facades.Validation().Make(input, rules, validation.PrepareForValidation(func(data validationcontract.Data) error {
  if name, exist := data.Get("name"); exist {
    return data.Set("name", name)
  }
  return nil
}))
```

## Работа с валидированными данными

После валидации входных данных запроса с помощью формы запросов или вручную созданных экземпляров валидатора, вы все равно захотите связать данные запроса с структурой. Существует два способа сделать это:

1. Используйте метод `Bind`, это привяжет все входящие данные, включая не проверенные данные:

```go
validator, err := ctx.Request().Validate(rules)
var user models.User
err := validator.Bind(&user)

validator, err := facades.Validation().Make(input, rules)
var user models.User
err := validator.Bind(&user)
```

2. Входящие данные автоматически привязываются к форме, когда вы используете запрос для валидации:

```go
var storePost requests.StorePostRequest
errors, err := ctx.Request().ValidateRequest(&storePost)
fmt.Println(storePost.Name)
```

## Работа с сообщениями об ошибках

### Получение одного сообщения об ошибке для поля (случайный)

```go
validator, err := ctx.Request().Validate(rules)
message := validator.Errors().One("email")
```

### Получение всех сообщений об ошибках для поля

```go
messages := validator.Errors().Get("email")
```

### Получение всех сообщений об ошибках для всех полей

```go
messages := validator.Errors().All()
```

### Определение наличия сообщений об ошибках для поля

```go
if validator.Errors().Has("email") {
  // 
}
```

## Доступные правила валидации

Ниже приведен список всех доступных правил валидации и их функций:

| Название | Описание |
| ----------- | ---------------------  |
| `required`  | Проверяет, что значение является обязательным и не может быть пустым.  |
| `required_if`  | `required_if:anotherfield,value,...` Поле проверки должно быть присутствовать и не пустым, если поле `anotherField` равно любому из значений.  |
| `required_unless`  | `required_unless:anotherfield,value,...` Поле проверки должно быть присутствовать и не пустым, если поле `anotherField` не равно любому из значений.  |
| `required_with`  | `required_with:foo,bar,...` Поле проверки должно быть присутствовать и не пустым, только если присутствует любое из других указанных полей. |
| `required_with_all`  | `required_with_all:foo,bar,...` Поле проверки должно быть присутствовать и не пустым, только если присутствуют все другие указанные поля.  |
| `required_without`  | `required_without:foo,bar,...` Поле проверки должно быть присутствовать и не пустым только в том случае, если отсутствуют другие указанные поля.  |
| `required_without_all`  | `required_without_all:foo,bar,...` Поле проверки должно быть присутствовать и не пустым только в том случае, если отсутствуют все другие указанные поля. |
| `int`  | Проверяет, что значение является типом `intX` `uintX` и поддерживает проверку размера. например: `int` `int:2` `int:2,12`. Внимание: [пункты использования правил](#int)  |
| `uint`  | Проверяет, что значение является типом `uint(uintX)` `uintX`, `value >= 0`  |
| `bool`  | Проверяет, что значение является булевым значением ("true": "1", "on", "yes", "true", "false": "0", "off", "no", "false"). |
| `string`  | Проверяет, что значение является строкой и поддерживает проверку размера. например: `string` `string:2` `string:2,12` |
| `float`  | Проверяет, что значение является типом `float(floatX)` |
| `slice`  | Проверяет, что значение является срезом типа (`[]

string`) |
| `min`  | Проверяет, что значение не меньше заданного значения. Внимание: [пункты использования правил](#min-max)  |
| `max`  | Проверяет, что значение не превышает заданное значение. Внимание: [пункты использования правил](#min-max)  |
| `between`  | Проверяет, что значение находится между двумя значениями (включительно). Внимание: [пункты использования правил](#between)  |
| `size`  | Проверяет, что значение имеет определенный размер (для числовых типов - количество знаков, для строк - количество символов, для срезов - количество элементов). Внимание: [пункты использования правил](#size)  |
| `len`  | Проверяет, что значение имеет точное количество элементов. Внимание: [пункты использования правил](#size)  |
| `alpha`  | Проверяет, что значение содержит только буквенные символы.  |
| `alpha_num`  | Проверяет, что значение содержит только буквенные символы и цифры.  |
| `alpha_dash`  | Проверяет, что значение содержит только буквенные символы, цифры, тире и подчеркивание.  |
| `email`  | Проверяет, что значение является допустимым адресом электронной почты.  |
| `url`  | Проверяет, что значение является допустимым URL-адресом.  |
| `json`  | Проверяет, что значение является допустимым JSON-объектом или массивом.  |
| `ip`  | Проверяет, что значение является допустимым IP-адресом (v4 или v6).  |
| `ipv4`  | Проверяет, что значение является допустимым IP-адресом версии 4.  |
| `ipv6`  | Проверяет, что значение является допустимым IP-адресом версии 6.  |
| `mac`  | Проверяет, что значение является допустимым MAC-адресом.  |
| `regex`  | Проверяет, что значение соответствует заданному регулярному выражению.  |
| `date`  | Проверяет, что значение является допустимой датой.  |
| `date_format`  | `date_format:format` Проверяет, что значение соответствует заданному формату даты.  |
| `date_between`  | Проверяет, что значение находится в диапазоне двух заданных дат.  |
| `time`  | Проверяет, что значение является допустимым временем (часы:минуты).  |
| `date_time`  | Проверяет, что значение является допустимой датой и временем.  |
| `time_between`  | Проверяет, что значение находится в заданном диапазоне времени.  |
| `before`  | `before:timestamp` Проверяет, что значение является датой, меньшей, чем заданная дата `timestamp`. Внимание: [пункты использования правил](#before-after)  |
| `after`  | `after:timestamp` Проверяет, что значение является датой, большей или равной заданной дате `timestamp`. Внимание: [пункты использования правил](#before-after)  |
| `in`  | `in:foo,bar,...` Проверяет, что значение содержится в списке заданных допустимых значений.  |
| `not_in`  | `not_in:foo,bar,...` Проверяет, что значение не содержится в списке заданных допустимых значений.  |
| `accepted`  | Проверяет, что значение равно "yes", "on", "1" или "true". Это часто используется для проверки флажков формы.  |
| `different`  | `different:field` Проверяет, что значение поля отличается от значения другого поля.  |
| `same`  | `same:field` Проверяет, что значение поля и значение другого поля совпадают.  |
| `gt`  | Проверяет, что значение больше заданного значения.  |
| `gte`  | Проверяет, что значение больше или равно заданному значению.  |
| `lt`  | Проверяет, что значение меньше заданного значения.  |
| `lte`  | Проверяет, что значение меньше или равно заданному значению.  |
| `exists`  | `exists:table,column` Проверяет, что значение поля существует в таблице и столбце.  |
| `unique`  | `unique:table,column,except,idColumn` Проверяет, что значение поля является уникальным в таблице и столбце. Вы можете использовать параметры `except` и `idColumn`, чтобы исключить определенные записи из проверки уникальности. Внимание: [пункты использования правил](#unique-exists)  |
| `size`  | `size:value` Проверяет, что размер среза, строки или числа равен заданному значению. Внимание: [пункты использования правил](#size)  |
| `length`  | `length:value` Проверяет, что длина строки или числа равна заданному значению. Внимание: [пункты использования правил](#size)  |
| `max_len`  | `max_len:value` Проверяет, что длина строки или числа не прев

ышает заданное значение. Внимание: [пункты использования правил](#min-max)  |
| `min_len`  | `min_len:value` Проверяет, что длина строки или числа не меньше заданного значения. Внимание: [пункты использования правил](#min-max)  |

Обратите внимание, что список правил может быть расширен путем добавления пользовательских правил валидации. Вы также можете настроить свои сообщения об ошибках и пользовательские значения атрибутов для всех правил валидации.